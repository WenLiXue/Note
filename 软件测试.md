## 软件测试

软件测试越早越好

软件缺陷越早找到越好

出现缺陷属于之间的关系：

程序人员犯了一个错误（mistake）->错误在程序或软件中就表现为缺陷   运行带有缺陷的软件或程序，就可能观察到失效/失败

**测试的目的就是为了找缺陷**

## 软件测试的原则

完全测试是不可能的

软件测试是有风险的行为

软件缺陷的群集现象（寄生虫性） 后面跟着的话会出判断题

Pareto原则 1：80%的缺陷出现在20%的空间中

Pareto原则 2

Pareto原则 3

杀虫剂的悖论：软件测试越多 免疫力越强 表现为同样的测试用例被重复使用多次 将不能发现新的缺陷

软件测试的不修复原则：原因：没有足够的时间  不算真正的软件缺陷 修复的风险太大 不值得修复

难以描述的软件缺陷：软件存在缺陷，但没有人能够发现，算不算缺陷？

## 软件缺陷的定义

1. 软件未达到产品说明书已经标明的功能呢
2. 软件出现了产品说明书中指明不会出现的错误
3. 软件未达到产品说明书中虽为指出但应当达到的目标
4. 软件功能超出了产品说明书中指明的范围
5. 软件测试人员认为软件难以理解、不易使用、或最终用户认为该软件使用效果不良

## 软件测试过程模型

V模型包括（A、B） 

W模型：测试和开发的并行关系，测试在整个开发过程贯穿

H模型：测试活动视为一个完全独立的活动，具有独立的包括测试准备活动和测试活动的流程，只要测试准备就绪，就可以开始测试执行活动  体现尽早准备尽早执行

X模型

# 黑盒测试

黑盒测试是站在用户的角度来进行的

## 黑盒测试考虑以下问题

- 如何测试功能呢的有效性
- 何种类型的输入会产生好的测试用例
- 系统是否对特定的输入值尤其敏感
- 如何分割数据类的边界
- 系统能够承受何种数据率和数据量
- 特定的数据

	## 等价类测试

设计测试比执行测试更重要

先从程序的规格说明书找出各个输入条件

等价类划分为：至少各有一个

- 有效等价类

  对软件规格说明而言，有意义的、合理的输入数据组成的集合

- 无效等价类

  至少有一个无效等价类	可以鉴别程序异常处理的情况

日期等价类划分   日期类型长度  年份范围  月份范围   日范围

设计测试用例要尽可能的覆盖所有有效等价类

每一个无效等价类要设计一个测试用例，一个测试用例可以覆盖多个有效等价类，但只能覆盖一个无效等价类

## 边界测试

单缺陷假设和多缺陷假设

x->[1,12],y->[1,31]

弱边界：只测试符合输入情况以内数据的数据  测试可以是：(x,y)->{(1,16),(2,16),(12,16),(11,16),(6,16),(6,1),(6,2).(6,31),(6,30)}

健壮性：测试对于超出符合输入情况数据内容的，包含弱边界的内容

(x,y)->{(1,16),(2,16),(12,16),(11,16),(6,16),(6,1),(6,2).(6,31),(6,30),(0,16),(13,16),(6,0),(6,32)}

单变量：对于一个含有n个变量的程序，采用边界值分析法测试程序会产生4n+1个测试用例

如果是健壮性则为6n+1

多变量：5^n 7^n（健壮性）

健壮性边界测试：可衡量软件对于规范要求意外的输入情况的处理能力

最坏情况测试



## 判定表法 决策表法   最严格最具有逻辑性的黑盒测试方法

使用的应用程序特征：

if-else结构明显



优点：

- 把复杂的问题按各种可能一一列举
- 简明而易于理解
- 可避免遗漏

缺点：

- 不能表达重复执行的动作
- 判定表不能很好地伸缩 n个条件就有2^n个规则

解决方法：大表化小表

基于判定表的测试不处理无效等价类，它不需要遵循单缺陷假设

## 因果图法

利用图解法分析输入的情况

因果图原因结果之间的关系;

- 恒等 	原因出现，结果出现；原因不出现，结果不出现
- 非 ~     原因出现，结果不出现；原因不出现，结果出现
- 或 V
- 与^

因果图的约束符号：

- E 互斥  几个原因不会同时成立	**原因之间**
- I 包含   几个原因至少成立一个    **原因之间**
- O 唯一  几个原因指挥成立一个   **原因之间**
- R 要求 结果a出现，b必须成立    **原因之间**
- M 屏蔽     **结果之间**

流程：

1. 分析那些是原因，那些是结果
2. 

# 白盒测试

基于程序的测试  

- 逻辑覆盖法：语句，判定，条件，判定-条件，条件覆盖，路径覆盖

1. 语句覆盖  点覆盖

   ​	每个可执行的语句至少被执行一次（所有节点），在保证测试的情况下，测试用例越少越好

   ​	缺点：

   - ​	逻辑覆盖中最弱的，虽然可以覆盖所有语句，但是不能说明逻辑的正确性
   - 可以直观地从源代码得到测试用例，无需细分

   

2. 判定覆盖  边覆盖

   控制图所有边都必须覆盖

   仍然存在漏洞，需要考虑各个条件的取值情况

   程序中每个判断条件的真值和假值都要覆盖   已经满足语句覆盖

3. 条件覆盖

   判定条件**内**的每个条件的每种可能都执行一次

   缺点：不能够满足判定覆盖

4. 判定-条件覆盖

4. 条件组合覆盖

   每个判断表达式的真假的各种组合都要覆盖    
   
   优点：前四种覆盖都能满足
   
   缺点：增加了测试用例的数量
   
4. 路径覆盖

   所有可能的路径全部覆盖

- 基本路径测试法

  **控制流图一个入口一个出口** 

  圈复杂度：

  求解：

  - V(G) = E-N+2   E是控制流图中边的数量，N是节点的数目
  - V(G) = P+1   P表示哦判断节点的数目
  - V(G) =A,A是控制流图中计算区域的数目

  在IBM中，白盒测试的最低标准语句覆盖和判定覆盖

  

