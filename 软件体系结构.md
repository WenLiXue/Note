# Analysis Results

- functional model 用例图 描述系统的功能
- structural model  类图  由类组成
- Behavioral model  顺序图  与系统的交互的对象  用例的执行流程
- Nonfunctional Requirements and constraints  Design Goal的来源   最后的需求数大于真正提出的非功能需求

# Design Goal

## Dependability Criteria

- Robustness: 系统韧性
- Reliability: 可以正确解决问题，不容易崩溃
- Availability: 可用性 随时随地可以使用  不宕机
- Safety和Security:前者表示物理安全  后者表示信息数据安全

## End User Criteria

- Utility: 是否会提供帮助
- Usability: 是否好用 容易上手

# 包图(package 一些类的集合)和组件(component)图 

掌握依赖即可

包：逻辑上

组件：物理上 构成整个系统的任何物理文件  

# System Decomposition

- System: 表示的是一个项目
- subsystem:整个系统的部分 可以独立存在  
- service: 一系列操作的集合  目的都是同一个	一组具有共同目的的相关操作   有一组接口来提供的  调用接口来提供服务
- interface： 组件向外提供的暴露的内容
- component:构成整个系统的任何物理文件
- package：用于分组类，在逻辑上形成了更高级别的单元。与命名空间类似，名称在同一个包内是唯一的。

## Package Design Principle - Coupling principles （包设计原则）

原因：类太多了，将类放入包中分类，要划分类，从逻辑的角度来划分

原则：

* REP （ 重用发布等价原则）  

​	整个发布单元都是复用的

* CRP （共同重用原则）

  一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么应该重用包中的所有类

* CCP 共同封闭原则

  一个变化若对包产生影响，则将对包中所有的类产生影响。而对其它的包不造成影响。

* ADP 无环路依赖原则

  在包图中依赖路径不应该存在环路，包结构理想为树结构

​		如果存在环路会存在的问题：很难发布版本，每个包都可能包含所有包

​		解决方法1.依赖倒转 ：一个类不用去依赖另一个类  只需依赖接口让其他类来实现	2.创建一个新包

* SDP 稳定依赖原则

​		不稳定的依赖稳定的包

​		解决方案：依赖倒转

 * SAP 稳定抽象原则

   包的抽象应该和包的稳定程度一致，抽象的就是稳定的，具体的就是不稳定的

## Design Philosophy 设计哲学

- 分而治之原则

- 高内聚低耦合

  高内聚的好处：容易改代码 容易测试代码 更好的可读性

  低耦合的好处：高耦合模块很难改变 高耦合模块

- 面向抽象设计

  隐藏细节 减少复杂性

  帮助理解本质

  主要方法：使用接口来new对象

  ```java
   List a = new ArrayList(); // new出来的对象 不能访问ArrayList里面的不存在List里面的元素
  ```

- 保持适度设计
- 避免重复设计 减少CV
- 不要使用过时技术（没人用），也不要用太新的技术（社区维护少，可能会被抛弃）
- 防御性设计

## Classic Architecture

* Layered Style - Closed Layer Style	没有服务层

* Layered Style - Open Layer Style      由服务层

  优点：可维护，可以并行开发，测试容易，复用性

  缺点：效率低

- Batch Processing Style（批处理风格）

  优点:简单易于实现

- PipleFilter Style(管道过滤器风格)   Linux操作系统
- Feedback Control Style（反馈控制风格）
