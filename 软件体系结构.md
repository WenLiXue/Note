# Analysis Results

- functional model 用例图 描述系统的功能
- structural model  类图  由类组成
- Behavioral model  顺序图  与系统的交互的对象  用例的执行流程
- Nonfunctional Requirements and constraints  Design Goal的来源   最后的需求数大于真正提出的非功能需求

## Design Goal

## Dependability Criteria

- Robustness: 系统韧性
- Reliability: 可以正确解决问题，不容易崩溃
- Availability: 可用性 随时随地可以使用  不宕机
- Safety和Security:前者表示物理安全  后者表示信息数据安全

## End User Criteria

- Utility: 是否会提供帮助
- Usability: 是否好用 容易上手

## 包图(package 一些类的集合)和组件(component)图 

掌握依赖即可

包：逻辑上

组件：物理上 构成整个系统的任何物理文件  

# System Decomposition

- System: 表示的是一个项目
- subsystem:整个系统的部分 可以独立存在  
- service: 一系列操作的集合  目的都是同一个	一组具有共同目的的相关操作   有一组接口来提供的  调用接口来提供服务
- interface： 组件向外提供的暴露的内容
- component:构成整个系统的任何物理文件
- package：用于分组类，在逻辑上形成了更高级别的单元。与命名空间类似，名称在同一个包内是唯一的。

## Package Design Principle - Coupling principles （包设计原则）

原因：类太多了，将类放入包中分类，要划分类，从逻辑的角度来划分

原则：

* REP （ 重用发布等价原则）  

​	整个发布单元都是复用的

* CRP （共同重用原则）

  一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么应该重用包中的所有类

* CCP 共同封闭原则

  一个变化若对包产生影响，则将对包中所有的类产生影响。而对其它的包不造成影响。

* ADP 无环路依赖原则

  在包图中依赖路径不应该存在环路，包结构理想为树结构

​		如果存在环路会存在的问题：很难发布版本，每个包都可能包含所有包

​		解决方法1.依赖倒转 ：一个类不用去依赖另一个类  只需依赖接口让其他类来实现	2.创建一个新包

* SDP 稳定依赖原则

​		不稳定的依赖稳定的包

​		解决方案：依赖倒转

 * SAP 稳定抽象原则

   包的抽象应该和包的稳定程度一致，抽象的就是稳定的，具体的就是不稳定的

## Design Philosophy 设计哲学

- 分而治之原则

- 高内聚低耦合

  高内聚的好处：容易改代码 容易测试代码 更好的可读性

  低耦合的好处：高耦合模块很难改变 高耦合模块

- 面向抽象设计

  隐藏细节 减少复杂性

  帮助理解本质

  主要方法：使用接口来new对象

  ```java
   List a = new ArrayList(); // new出来的对象 不能访问ArrayList里面的不存在List里面的元素
  ```

- 保持适度设计
- 避免重复设计 减少CV
- 不要使用过时技术（没人用），也不要用太新的技术（社区维护少，可能会被抛弃）
- 防御性设计

# Classic Architecture

调用返回风格

数据流风格

独立组件风格

仓库风格

黑板风格

虚拟机风格

解释器风格

* Layered Style - Closed Layer Style	没有服务层		四层结构：数据库 持久层 业务层 表示层（UI）  可能会多个服务层

* Layered Style - Open Layer Style      由服务层

  优点：可维护，可以并行开发，测试容易，复用性

  缺点：效率低

- Batch Processing Style（批处理风格）

  优点:简单易于实现

- PipleFilter Style(管道过滤器风格)   Linux操作系统

- Feedback Control Style（反馈控制风格）

# Distributed System 分布式结构

何为分布式？ 将系统的不同部分放在不同的机器中，分开部署

Host+simulation terminal architecture 主机模拟终端结构

FIle sharing architecture 文件共享结构

### Client/server architecture 

​	客户端服务器结构	服务器提供服务 客户端请求服务

​	原始：客户端： 服务器：数据库持久层表示层 应用层

​	缺点：客户端负担小 服务器负担很重

#### 改进：Client-Based Architecture 

瘦客户端变为胖客户端	客户端： 服务器：数据库 持久层表示层 应用层

​	标准CS架构  客户端：表示层 应用层 服务器：数据库 持久层

​	CS结构风格：P2P结构 端到端结构  

#### mutl-tier C/S结构风格

表示层	功能层（有很多层）数据层

优点：

缺点：通信效率低

#### B/S Architecture Style	是一种特殊的C/S结构

优点：维护花费低 安全性高 容错扩展高

缺点：性能差  UI设计差 比较难  所以就会有前端工程师

P2P特殊的CS结构

#### Middleware 中间件

连接不同的组件和平台,存储消息队列

#### Model-View-Controller		MVC    **重要**

解决的问题：

- 用store数据更新代替页面频繁dom操作，简化业务代码；
- 全局暂存数据，避免重复请求数据资源；
- 模块解耦，组件化开发，避免功能模块间互相影响；解view 和 controller的耦
- 局部刷新，减少页面刷新次数，提高用户体验。解决多视图数据不同步的问题

Model 模型

View	视图

Controller	控制器

流程：先绑定模型视图，该模型，视图跟着更改

优点：维护性好 低耦合 复用性 可管理

缺点：性能差 简化性差 效率低

MVC和三层架构不同，是三角架构

流行的架构：微内核架构 vscode就是这种结构 只有核心的内容 可以仔细扩展

优点：

微服务架构

# Design Principle

==期末重点考察==

## design smell 7sins

- Rigidity 设计僵硬 很难修改 不灵活
- Fragility 脆弱性  一改系统就坏  鲁棒性反义
- Immoility 难以复用
- Viscosity 黏性 不易作对事情，容易做错事
- Needless complexity  过度设计
- Needless Reptition 没有必要的重复  重复是魔鬼  一个地方修改重复的地方都要修改  代码冗余
- Opacity 代码不透明 不清楚

## 设计原则

- SRP 单一职责原则 ：一个类只做一件事情，不只是类也可以是一个单元   方法 包 子系统 都可可复用  可测试

- OCP 开闭原则         对扩展开放  对修改关闭（将可能的修改进行抽象  面向抽象 面向接口）  可维护 可扩展；  

- LSP 里氏替换原则   子类应该可以重写父类的任何方法，子类可以替换父类

  好处：可维护性、可扩展性、可读性、鲁棒性、可复用性

- DIP 依赖倒转原则  层与层之间使用依赖倒置原则 层之间不直接依赖，一个依赖抽象，一个实现抽象   发生变化高层和低层不会直接相互影响

  ```java
  // 修改前
  public class Button{
      private Lamp itsLamp;
      public void poll()
      {
  	if(```)
          itsLamp.turnOn();
      }
  }
  // 解耦之后的关系
  public class Button()
  {
      public void poll(){}
      public  void turnOn();
      public  void turnOff();
      
  }
  interface switch()
  {
        public  void turnOn();
        public  void turnOff();
  }
  
  ```
  
  - ISP 接口隔离原则  用户不应该依赖不能实现的接口
  - LOD  迪米特法则  最小知识原则  只能会最亲密的类有关系 shy code  减少依赖  更好的维护性  拒绝链式写法
  - CARP 合成复用原则  继承存在副作用 如果想要复用一个方法 一些方法并不需要  继承不可取

# Design Pattern(设计模式)



模式是在一个环境下一个问题的解决方式

GOF - 设计模式：可复用面向对象软件的基础

## Singleton 单例

###  ==和equals方法的区别		

**== 的作用：**
　　基本类型：比较的就是值是否相同
　　引用类型：比较的就是地址值是否相同   若两个类比较需要比较hashcode->即两个对象所在的地址
**equals 的作用:**
　　引用类型：默认情况下，比较的是地址值。
注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同



```java
// 饿汉式   没有被调用就已经创建了	多线程下  线程安全
class Singleton{
    private Singleton(){};
    private  static Singleton instance = new Singleton();
    public static Singleton GetInstance()
    {
        return singleton;
    }
}
// 懒汉式   懒加载    多线程下  线程不安全
class Singleton{
    private Singleton(){};
    private  static Singleton instance;
    public static Singleton GetInstance()
    {
        if(instance = null)
            instance = new Singleton();
        return singleton;
    }
}
// 线程安全 懒汉式
class Singleton{
    private Singleton(){};
    private  static Singleton instance;
    public static  synchronized Singleton GetInstance()
    {
        if(instance = null)
            instance = new Singleton();
        return singleton;
    }
}
// 双重校验
class Singleton{
    private Singleton(){};
    private  static Singleton instance;
    public static  synchronized Singleton GetInstance()
    {
        if(instance = null)
        {
            
            if(instance = null){
                instance = new Singleton();
            }
        }
            
        return singleton;
    }
}
// 静态内部类

// 枚举模式
```

three enemies:

- multi-thread
- reflection
- Desenerilization



优点：

​	节省内存

​	避免

缺点：

​	没有接口，没有继承

​	违背单一职责原则

## Factory Model 工厂模式

三个相关的模式：

- simple Factory
- Factory Method
- Abstract Factory

### simple Factory

### Factory Method

抽象工厂  一个工厂只生产一个东西

需要加新的东西  增加工厂类和工厂制作类即可，客户端再改变

改配置文件？

### Abstract Factory









