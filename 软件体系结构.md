# Analysis Results

- functional model 用例图 描述系统的功能
- structural model  类图  由类组成
- Behavioral model  顺序图  与系统的交互的对象  用例的执行流程
- Nonfunctional Requirements and constraints  Design Goal的来源   最后的需求数大于真正提出的非功能需求

## Design Goal

## Dependability Criteria

- Robustness: 系统韧性
- Reliability: 可以正确解决问题，不容易崩溃
- Availability: 可用性 随时随地可以使用  不宕机
- Safety和Security:前者表示物理安全  后者表示信息数据安全

## End User Criteria

- Utility: 是否会提供帮助
- Usability: 是否好用 容易上手

## 包图(package 一些类的集合)和组件(component)图 

掌握依赖即可

包：逻辑上

组件：物理上 构成整个系统的任何物理文件  

# System Decomposition

- System: 表示的是一个项目
- subsystem:整个系统的部分 可以独立存在  
- service: 一系列操作的集合  目的都是同一个	一组具有共同目的的相关操作   有一组接口来提供的  调用接口来提供服务
- interface： 组件向外提供的暴露的内容
- component:构成整个系统的任何物理文件
- package：用于分组类，在逻辑上形成了更高级别的单元。与命名空间类似，名称在同一个包内是唯一的。

## Package Design Principle - Coupling principles （包设计原则）

原因：类太多了，将类放入包中分类，要划分类，从逻辑的角度来划分

原则：

* REP （ 重用发布等价原则）  

​	整个发布单元都是复用的

* CRP （共同重用原则）

  一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么应该重用包中的所有类

* CCP 共同封闭原则

  一个变化若对包产生影响，则将对包中所有的类产生影响。而对其它的包不造成影响。

* ADP 无环路依赖原则

  在包图中依赖路径不应该存在环路，包结构理想为树结构

​		如果存在环路会存在的问题：很难发布版本，每个包都可能包含所有包

​		解决方法1.依赖倒转 ：一个类不用去依赖另一个类  只需依赖接口让其他类来实现	2.创建一个新包

* SDP 稳定依赖原则

​		不稳定的依赖稳定的包

​		解决方案：依赖倒转

 * SAP 稳定抽象原则

   包的抽象应该和包的稳定程度一致，抽象的就是稳定的，具体的就是不稳定的

## Design Philosophy 设计哲学

- 分而治之原则

- 高内聚低耦合

  高内聚的好处：容易改代码 容易测试代码 更好的可读性

  低耦合的好处：高耦合模块很难改变 高耦合模块

- 面向抽象设计

  隐藏细节 减少复杂性

  帮助理解本质

  主要方法：使用接口来new对象

  ```java
   List a = new ArrayList(); // new出来的对象 不能访问ArrayList里面的不存在List里面的元素
  ```

- 保持适度设计
- 避免重复设计 减少CV
- 不要使用过时技术（没人用），也不要用太新的技术（社区维护少，可能会被抛弃）
- 防御性设计

# Classic Architecture

调用返回风格

数据流风格

独立组件风格

仓库风格

黑板风格

虚拟机风格

解释器风格

* Layered Style - Closed Layer Style	没有服务层		四层结构：数据库 持久层 业务层 表示层（UI）  可能会多个服务层

* Layered Style - Open Layer Style      由服务层

  优点：可维护，可以并行开发，测试容易，复用性

  缺点：效率低

- Batch Processing Style（批处理风格）

  优点:简单易于实现

- PipleFilter Style(管道过滤器风格)   Linux操作系统

- Feedback Control Style（反馈控制风格）

# Distributed System 分布式结构

何为分布式？ 将系统的不同部分放在不同的机器中，分开部署

Host+simulation terminal architecture 主机模拟终端结构

FIle sharing architecture 文件共享结构

### Client/server architecture 

​	客户端服务器结构	服务器提供服务 客户端请求服务

​	原始：客户端： 服务器：数据库持久层表示层 应用层

​	缺点：客户端负担小 服务器负担很重

#### 改进：Client-Based Architecture 

瘦客户端变为胖客户端	客户端： 服务器：数据库 持久层表示层 应用层

​	标准CS架构  客户端：表示层 应用层 服务器：数据库 持久层

​	CS结构风格：P2P结构 端到端结构  

#### mutl-tier C/S结构风格

表示层	功能层（有很多层）数据层

优点：

缺点：通信效率低

#### B/S Architecture Style	是一种特殊的C/S结构

优点：维护花费低 安全性高 容错扩展高

缺点：性能差  UI设计差 比较难  所以就会有前端工程师

P2P特殊的CS结构

#### Middleware 中间件

连接不同的组件和平台,存储消息队列

#### Model-View-Controller		MVC    **重要**

解决的问题：

- 用store数据更新代替页面频繁dom操作，简化业务代码；
- 全局暂存数据，避免重复请求数据资源；
- 模块解耦，组件化开发，避免功能模块间互相影响；解view 和 controller的耦
- 局部刷新，减少页面刷新次数，提高用户体验。解决多视图数据不同步的问题

Model 模型

View	视图

Controller	控制器

流程：先绑定模型视图，该模型，视图跟着更改

优点：维护性好 低耦合 复用性 可管理

缺点：性能差 简化性差 效率低

MVC和三层架构不同，是三角架构

流行的架构：微内核架构 vscode就是这种结构 只有核心的内容 可以仔细扩展

优点：

微服务架构

# Design Principle

## design smell 7sins

- Rigidity 设计僵硬 很难修改 不灵活
- Fragility 脆弱性  一改系统就坏  鲁棒性反义
- Immoility 难以复用
- Viscosity 黏性 不易作对事情，容易做错事
- Needless complexity  过度设计
- Needless Reptition 没有必要的重复  重复是魔鬼  一个地方修改重复的地方都要修改  代码冗余
- Opacity 代码不透明 不清楚

## 设计原则

- SRP 单一职责原则 ：一个类只做一件事情

- OCP 开闭原则  对扩展开放  可维护 可扩展；

