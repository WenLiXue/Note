# 操作系统笔记

# 介绍

## INTERFACE（接口、界面、介面）

- 接口是连接两个物体的边界，通过这个界面，可以很好的对话。
- 硬件-硬件  USB VGA HDMI 
- 软件-硬件 指令集，程序如何调用CPU工作，就是考的提供给软件的指令集
- 软件-软件 API（Application Programming Interface） 调用某个函数

## Virtual Machine 虚拟机

操作系统向用户提供一个容易理解和使用的计算机（虚拟的），用户对这个计算机的操作都将被操作系统转成对计算机硬件的操作

操作系统类似中介，将软件和硬件联系起来

![image-20230918171600005](C:\Users\23882\AppData\Roaming\Typora\typora-user-images\image-20230918171600005.png)

## Functions 

操作系统能做什么？

- 用户的角度

  提供良好的用户界面

  标准的函数库

  使编程更加方便并且不容易出错

- 系统的角度

  管理资源

  - 硬件资源（处理机、存储器、设备）
  - 信息资源（文件）

  解决申请资源时产生的冲突

  阻止错误的产生对计算机不正常的使用  比如访问越界、抵抗木马病毒

## 定义

操作系统扮演了电脑用户和电脑硬件的中间人

执行程序高效便利

## 计算机系统组成

数据线送到内存再送到CPU，所有的设备共享内存

![image-20230918172454079](C:\Users\23882\AppData\Roaming\Typora\typora-user-images\image-20230918172454079.png)

## 操作系统如何启动？

![image-20230918173118125](C:\Users\23882\AppData\Roaming\Typora\typora-user-images\image-20230918173118125.png)

## 中断

当有事件发生时，CPU会收到一个中断信号，可以是硬中断也可以是软件中断

CPU会停下正在做的事情，转而执行中断处理程序

操作系统是一个中断驱动的系统

## 存储系统

CPU负责将指定村内存读入，所以程序必须在内存中才能运行

内存以字节为存储单位，每个字节都有一个地址与之对应。通过load/store指定即可访问指定地址的内存数据

load:将内存数据装入寄存器

store:将寄存器数据写入内存

## 存储层次图

容量从上到下逐渐增大，读写速度逐渐变小

易失性存储和非易失性存储的区别就是，断电后里面的内容是否还存在，有电才能存储

![image-20230918173827599](C:\Users\23882\AppData\Roaming\Typora\typora-user-images\image-20230918173827599.png)

## I/O结构

IO设备的种类非常多（比如音响、手柄等），管理IO子系统非常复杂

![image-20230918174655161](C:\Users\23882\AppData\Roaming\Typora\typora-user-images\image-20230918174655161.png)

操作IO设备需要驱动程序，

## 操作系统结构

- 单用户弹道模式：一次只执行一个任务，浪费时间，串行执行，CPU利用率低
- 多道程序设计：可以让CPU和IO设备始终忙碌，提高CPU的利用率，需要处理器和IO设备具有并行工作的能力

- 分时系统：多任务系统，允许多个用户一台计算机，彼此不会感觉到共用了一台计算机，用户只有输入输出设备，分时系统为每个用户轮流分配等量的CPU时间，用户发出指令得到及时结果称为响应时间，第一个分时系统CTSS由1962开发出来
-  当今的操作系统也借鉴了分时系统的思路，虽然是一个用户使用一台电脑，但是此时的多个用户变为了多个应用，轮流分配等量的CPU时间来执行

## 引发的其他模式

- 处理器调度 CPU Scheduling
- 交换 Swapping
- 虚拟内存 Virtual Memory
- 磁盘管理 Disk Management
- 同步 Synchronization
- 死锁 Deadlock  同步没做好回引发的现象

# Lecture2 操作系统结构

### 用户接口 User Interface(UI)

- CIL(comand line interface) 命令行接口    命令行解释器(shell)
- GUI （graphic user interface） 图形化用户接口  用户友好地friendly
- Batch   一个文件包含很多命令和指示  批处理

## 系统调用System Call

- 系统调用提供了访问和使用操作系统所提供的服务接口  属于操作系统的代码  操作系统级别的代码
  - 系统调用的代码时操作系统级别的
  - 面向程序员的提供的

- API(Application Programming Interface)  ：指明了参数和返回值的一组函数  

  - 程序员通过调用API，间接使用系统调用
  - Windows API/POSIX API /JAVA API

  ## 双重模式（Dual Mode）

  - 用于划分系统的运行状态
    - 用户模式；执行用户代码          (user mode)
    - 内核模式：执行操作系统代码 （kernel mode）

  -  目的：确保操作系统正确的运行
  - 实现方式：用一个硬件模式位来表示当前模式；0表示内核模式，1表示用户模式

  ## 运行模式的切换

  - 系统调用需要在哪种模式下运行？ 内核态
  - 你的应用程序需要在哪种模式下运行? 用户态
  - 如何切换？ 中断机制来切换

  ## 系统调用的实现机制

  - 每个系统调用都有一个唯一的数字编号，被称为函数调用号
  - 用户调用API时，API会向系统调用接口指明所要用的系统号，操作系统内核维护了一张索引表，依据这个调用号可索引到访问系统调用代码在内核中的位置

# Lecture3 进程概念

## 程序和进程

- 程序是被动实体，比如包含一系列存储在磁盘中的指令（通常被叫做可执行文件）
- 程序变为进程时，是当一个可执行文件被加载入内存中
- 进程是一个主动实体，由一个程序计数器（PC）指定下一条指令来执行一系列相关资源

进程在内存中的分布

![image-20230926165607389](C:\Users\23882\AppData\Roaming\Typora\typora-user-images\image-20230926165607389.png)

### 并发和并行的区别：

- 并发：两个或者两个以上的事件在相同的时间==发生或存在==，同时存在但不同时运行
- 并行：两个或者两个以上的事件在相同的时间==运行==

进程并发的动机：多道程序设计

单核CPU的情况下并发的进程A,B, A运行一会B运行一会  

### 并发进程共享CPU

- 并发进程可能无法一次性执行完毕，会==走走停停==

- 一个进程在执行过程 中可能会被另一个进程替换占有CPU，这个过程被称作是“==进程切换==”

## 进程的定义

- 进程是一个程序的一次执行过程
  - 能完成具体的功能
  - 是在某个数据集合上完成的
  - 执行过程是可并发的

- 进程是资源分配、保护和调度的基本单位    （在没有引入线程时）

## 进程的状态

进程在执行期间自身状态发生变化，进程有三种基本状态，分别是：

- 运行态（Running）：此时进程的代码在CPU上运行
- 就绪态（Ready）：进程具备运行条件，等待分配CPU（CPU正在被使用等待分配）
- 等待态（Waiting）：进程在等待某些事件的发生（比如IO操作结束或者一个信号）

## 进程何时离开CPU

- 内部事件
  - 进程主动放弃进入CPU，进入等待或者终止状态
  - 使用I/O设备，（非）正常结束

- 外部事件
  - 进程被剥夺CPU使用权，进入就绪状态，被抢占
  - 时间片到达
  - 高优先权进程到达

# Lecture4 Process Scheduling 进程调度

## 并发进程的切换

- 并发进程中，一个运行着的进程被其他进程替换占有CPU，这个过程就叫==进程切换==
- 原因：CPU资源时有限的

## 中断技术

- 中断是指程序执行过程中
  - 当发生某个事件时，中止CPU上现行的程序的运行
  - 引出该事件的处理程序执行
  - 执行完毕返回原程序中断点继续执行

## 中断源

- 外中断：来自CPU以外的硬件中断信号
  - 如时钟中断、键盘中断、外围设备中断
  - 外部中断均是异步中断   ==异步可以理解为随机==
- 内中断（异常Exception）：来自处理器内部，==指令执行过程中发生的中断==，属于同步中断
  - 硬件异常：掉电、奇偶校验错误
  - 程序异常：非法操作、地址越界、断点、除数为0
  - 系统调用  

## 模式切换

- 中断是用户态向核心态转换的==唯一途径==！系统调用是中断的一种
- OS提供Load PSW指令装载用户进程返回用户状态

## 进程切换

- 切换时机
  - 进程需要进入等待状态   主动
  - 进程被抢占CPU而进入就绪状态  被动

- 切换过程     先从用户态变为核心态
  - 保存被中断进程的上下文信息
  - 修改被中断进程的控制信息
  - 将被中断的进程加入相应的状态队列
  - 调度一个新的进程并恢复它的上下文信息
  
  ==进程切换有开销 时空资源==

# Lecture5 Threads 线程

动机：一些同时任务想要能够同时运行不要顺序执行

同一进程下的线程共享，每个线程有自己的寄存器和栈，代码、静态变量、全局变量是共享的

### 多线程的优点：

- 响应性高
- 资源共享     代码、静态变量、全局变量是共享的
- 经济            线程之间的切换比进程之间的切换更加经济
- 可伸缩性   多核   并发线程可以做到并行运算   单核和多核之间可以自由切换

## 线程定义

- 线程是CPU利用的基本单位，也==调度的基本单位==，它包含线程ID，PC，寄存器集合，栈（局部变量）
- 和其他属于同一个进程中的其他线程共享代码，代码部分，数据部分(heap、data)，其他操作系统资源（打开的文件、信号）
- 传统的进程只有一个线程（heavy weight），如果一个线程有多线程控制(light weight)，它可以一次执行多个任务

## 多核编程

在多处理器系统中，多核编程机制可以让应用程序可以有效的将自身执行的多个任务（并发编程）分散到不同的处理器上运行，以实现并行计算

## 多线程模型

- 用户线程（User Level Thread）

  只在用户态下运行，管理无需内核支持

- 内核线程（Kernel Level Thread）

  在内核态下运行，由操作系统支持和管理

  模型分类

  - M:1 多对一模型

    优点：提供逻辑上的并行

    缺点：实际上是不是并行的，线程都使用一个KLT，如果出现一个阻塞，所以线程都会阻塞

  - 1：1模型

    优点：并发+并行

    缺点：内核开销很大，每个线程都对应一个内核线程

  - M:M模型

    优点：节省内核开销

    缺点：实现起来复杂

## 线程库

- Thread Library为程序员提供创建和管理线程的API
  - POSIX Thread:用户线程和内核线程库
  - Windows Thread：内核线程库
  - Java Thread：依据所依赖的操作系统而定

# Lecture 7 Synchronization 同步

## 并发进程/线程

内存中存在的若干进程/线程，由操作系统的调度采用适当的策略将他们调度到CPU（s）上运行，同时维护他们的状态队列

- 多个并发进程/线程从宏观上是同时在运行的
- 从微观上，他们的运行过程是走走停停的
- 并发进程/线程的之间是==交替执行==的

## 并发进程之间的关系

- 独立关系
  - 并发进程分别在自己的变量集合上运行,不共享变量
  - 例子：chrome进程和music进程  两者之间没有关系
- 交互关系
  - 并发进程执行过程中需要共享或是交换数据
  - 例如：银行服务器上的receiver进程和handler进程
  - 交互的并发进程之间又存在着==竞争==和==协作==的关系

## 异步

asynchronous means RANDOM！ 异步就是随机、随性，casual，不受任何控制

## 同步

- 进程同步是维护被交互进程所共享数据一致性的机制
- 同步工具
  - Mutex lock  互斥锁
  - Semaphore  信号量

# Lecture 8 Mutex Locks  互斥锁



